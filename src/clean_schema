#!/usr/bin/env node
const fs = require('fs');
const readline = require('readline');

// remove whole CREATE statements if it's not in this list
const validCreateStatements = new Set([
  'GLOBAL',
  // 'INDEX',
  'LOCAL',
  'SCHEMA',
  'SEQUENCE',
  'TABLE',
  'TEMP',
  'TEMPORARY',
  'TYPE',
  'UNIQUE',
  'UNLOGGED',
  'VIEW',
]);

const DEV = false;
const write = (tag, line) => {
  if (tag === 'drop') return;

  if (DEV) {
    tag = tag.toLowerCase();
    process.stdout.write(tag);
    if (tag.length > 0) {
      process.stdout.write(':');
      if (line.length > 0) process.stdout.write(' ');
    }
  }

  process.stdout.write(line);
  process.stdout.write('\n');
};

let createStatement = null;
let continuousNewLines = 0;

const input = process.argv[2] ? fs.createReadStream(process.argv[2]) : process.stdin;
readline.createInterface({ input }).on('line', (line) => {
  // 1. check the continuousNewLines
  if (line.length === 0) {
    continuousNewLines++;
    if (continuousNewLines === 2) {
      continuousNewLines = 0;
      createStatement = null;
      // console.log('~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~');
    }
  } else {
    // reset to 0
    continuousNewLines = 0;
  }

  // It's create statement block
  if (createStatement !== null) {
    // Invalid CREATE statement
    if (!validCreateStatements.has(createStatement)) {
      write('drop', line);
      return;
    }

    // Valid CREATE statement
    if (createStatement === 'TABLE') {
      // 1. if type has ".", remove the prefix schema name
      line = line.replace(/(^\s*\w+ )\w+\.(\w+.*$)/, (match, p1, p2, offset, string) => {
        return p1 + p2;
      });

      // 2. if has [], rename to 'xxx_array'
      line = line.replace(/(^\s*\w+ \w+)\[\](.*$)/, (match, p1, p2, offset, string) => {
        return `${p1}_array${p2}`;
      });

      // 3. if DEFAULT has ::, remove the DEFAULT
      line = line.replace(/(^.*)( DEFAULT.+$)/, (match, p1, p2, offset, string) => {
        return !p2.includes('::')
          ? string // don't have ::
          : p1 + (p2[p2.length - 1] === ',' ? ',' : ''); // has ::, and check last ,
      });
    }
    write(createStatement, line);
    return;
  }

  // check ALTER statements
  let result = line.match(/^ALTER (\w+)/);
  if (result && result[1] !== 'TABLE') {
    // ALTER TABLE is the only valid ALTER statement
    write('drop', line);
    return;
  }

  // check CREATE statements
  result = line.match(/^CREATE (\w+)/);
  if (result === null) {
    // NOT CREATE statement
    createStatement = null;
    write('', line);
    return;
  }

  createStatement = result[1];

  // Valid CREATE statement
  if (validCreateStatements.has(createStatement)) {
    if (createStatement === 'TYPE') {
      // if type has ".", remove the prefix schema name
      line = line.replace(/(^CREATE TYPE )\w+\.(\w+.*$)/, (match, p1, p2, offset, string) => {
        return p1 + p2;
      });
    }
    write(createStatement, line);
    return;
  }

  // Invalid CREATE statement => Drop this line
  write('drop', line);
});
